<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as Coordinates from
      "./coordinates.js"
    
      var S = Math.sin
      var C = Math.cos
    
      var rendererOptions = {
        ambientLight: 1,
        fov: 1400
      }
      var renderer = await Coordinates.Renderer(rendererOptions)
      
      renderer.z = 10
      renderer.yaw = Math.PI
      
      Coordinates.AnimationLoop(renderer, 'Draw')

      //var refTexture = 'https://i.imgur.com/bTHLMLp.mp4'
      var refTexture = 'https://i.imgur.com/Wynns6w.mp4'
      var shaders = []

      var shaderOptions = [
        { uniform: {
          type: 'phong',
          value: 0,
        } },
      ]
      var nullShader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shaderOptions = [
        { lighting: {
          type: 'ambientLight', value: -.25
        }},
        { uniform: {
          type: 'phong',
          value: .6,
          theta: Math.PI,
        } },
        
        { uniform: {
          type: 'reflection',
          value: .5,
          map: refTexture,
        } },
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)
      shaders = [...shaders, shader]

      var shaderOptions = [
        { lighting: {
          type: 'ambientLight', value: .25
        }},
        { uniform: {
          type: 'phong',
          value: 2.5,
          theta: Math.PI,
          enabled: true,
        } },
        { uniform: {
          type: 'reflection',
          value: .5,
          map: refTexture,
          enabled: true,
        } },
      ]
      var floorShader = await Coordinates.BasicShader(renderer, shaderOptions)
      shaders = [...shaders, floorShader]

      var shaderOptions = [
      ]
      var nullShader = await Coordinates.BasicShader(renderer, shaderOptions)
      
      // background
      var shaderOptions = [
        { lighting: {
          type: 'ambientLight', value: 2
        }},
        { uniform: {
          type: 'phong',
          value: 0,
        } }
      ]
      var backgroundShader = await Coordinates.BasicShader(renderer, shaderOptions)


      var shapes = []

      var geoOptions = {
        shapeType: 'custom shape',
        url: 'https://srmcgann.github.io/Coordinates/custom shapes/angel 1.json',
        map: 'https://srmcgann.github.io/Coordinates/custom shapes/angel 1.jpg',
        color: 0x333333,
        colorMix: 0,
        subs: 0,
        y: 0,
        yaw: Math.PI,
        //sphereize: 0,
        //equirectangular: true,
        size: 4,
      }
      if(1) await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await shader.ConnectGeometry(geometry)
      })
      
      
      var texCoords = []
      var geometryData = []
      var cl = 2
      var rw = 2
      var br = 2
      var sp  = 1
      var tx  = 0
      var ty  = 0
      var tz  = 0
      var l, X, Y, Z
      
      var cl_
      Array((cl_=cl+1)*rw*br).fill().map((v, i) => {
        var a = [], b = []
        var ax = 0
        var ay = 0
        var az = 0
        var ct = 0
        if((i+1)%cl_){
          l = i
          X = tx + ((l%cl_) - cl_/2 + .5) * sp
          Y = ty + (((l/cl_|0)%rw) - rw/2 + .5) * sp
          Z = tz + ((l/cl_/rw|0) - br/2) * sp
          ax += X
          ay += Y
          az += Z
          ct ++
          a = [...a, [X,Y,Z]]
          b = [...b, [0, 0]]
          l = i + 1
          X = tx + ((l%cl_) - cl_/2 + .5) * sp
          Y = ty + (((l/cl_|0)%rw) - rw/2 + .5) * sp
          Z = tz + ((l/cl_/rw|0) - br/2) * sp
          ax += X
          ay += Y
          az += Z
          ct ++
          a = [...a, [X,Y,Z]]
          b = [...b, [1, 0]]
          l = i + 1 + cl_*rw // br
          X = tx + ((l%cl_) - cl_/2 + .5) * sp
          Y = ty + (((l/cl_|0)%rw) - rw/2 + .5) * sp
          Z = tz + ((l/cl_/rw|0) - br/2) * sp
          ax += X
          ay += Y
          az += Z
          ct ++
          a = [...a, [X,Y,Z]]
          b = [...b, [1, 1]]
          l = i + cl_*rw     // br
          X = tx + ((l%cl_) - cl_/2 + .5) * sp
          Y = ty + (((l/cl_|0)%rw) - rw/2 + .5) * sp
          Z = tz + ((l/cl_/rw|0) - br/2) * sp
          ax += X
          ay += Y
          az += Z
          ct ++
          a = [...a, [X,Y,Z]]
          b = [...b, [0, 1]]
          ax /= ct
          ay /= ct
          az /= ct
          if(Math.hypot(ax, az) < Math.hypot(cl_*sp, br*sp)/2){
            geometryData = [...geometryData, a]
            texCoords    = [...texCoords,    b]
          }
        }
      })
      
      var floorNormalAssocs = []
      var geoOptions = {
        shapeType: 'dynamic',
        name: 'floor',
        geometryData,
        texCoords,
        x: 0,
        y: 0,
        z: 0,
        color: 0xffffff,
        colorMix: 0,
        subs: 2,
        sphereize: 0,
        averageNormals: 0,
        showNormals: false,
        flipNormals: false,
        equirectangular: false,
        size: 10,
        map: 'https://srmcgann.github.io/Coordinates/resources/grid_burgundy_dark_po2.jpg'
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        for(var i = 0; i < geometry.vertices.length; i+=3){
          var X1 = geometry.vertices[i+0]
          var Y1 = geometry.vertices[i+1]
          var Z1 = geometry.vertices[i+2]
          var a = []
          for(var j = 0; j < geometry.vertices.length; j+=3){
            var X2 = geometry.vertices[j+0]
            var Y2 = geometry.vertices[j+1]
            var Z2 = geometry.vertices[j+2]
            
            if(Math.hypot(X1-X2, Y1-Y2, Z1-Z2) < .001){
              a = [...a, j]
            }
          }
          floorNormalAssocs = [...floorNormalAssocs, a]
        }
        await floorShader.ConnectGeometry(geometry)
      })
      
      
      var geoOptions = {
        shapeType: 'dodecahedron',
        name: 'background',
        geometryData,
        x: 0,
        y: 0,
        z: 0,
        color: 0xffffff,
        colorMix: 0,
        subs: 3,
        sphereize: 0,
        averageNormals: false,
        showNormals: false,
        //equirectangular: true,
        size: 1e3,
        map: refTexture
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await backgroundShader.ConnectGeometry(geometry)
      })
      

      var geoOptions = {
        shapeType: 'point light',
        name: 'light',
        x: 70,
        y: 10,
        z: 0,
        color: 0xffdd88,
        colorMix: 0,
        size: 12,
        lum: 4,
        map: 'https://srmcgann.github.io/Coordinates/resources/stars/star2.png',
        pointLightShowSource: true,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await nullShader.ConnectGeometry(geometry)
      })
      

      var a
      // hex
      cl = 4
      rw = cl * 4
      br = 1
      var ox = 0
      var oy = 0
      var oz = -1
      var sd = 6
      var ls = 1, p
      sp = ls * 3
      if(0) Array(cl*rw*br).fill().map(async (v, i) => {
        var tx = ox + ((i%cl)-cl/2 + .5) * sp + ((i/cl|0)%2?-sp:sp)/4
        var ty = oy + (((i/cl|0)%rw)-rw/2 + .5) * sp / 3 * (.75**.5)
        if(Math.hypot(tx, ty) < 5){
          tx += ox
          ty += oy
          tz += oz
          var tz = oz + ((i/cl/rw|0)-br/2 + .5) * sp
          if(0){
            geometryData = []
            texCoords    = []
            a = []
            for(var i = sd; i--;){
              X = tx + S(p=Math.PI*2/sd*i + Math.PI/sd) * ls / 1.1
              Y = ty + C(p) * ls / 1.1
              Z = tz
              a = [...a, [X,Y,Z]]
            }
            geometryData = [...geometryData, a]
            var geoOptions = {
              shapeType: 'dynamic',
              name: 'hex',
              geometryData,
              x: 0,
              y: 10,
              z: 0,
              color: Coordinates.HexFromHSV(360/cl*rw*br*i*2,1,1),
              colorMix: .5,
              subs: 1,
              sphereize: .8,
              averageNormals: true,
              showNormals: false,
              equirectangular: true,
              size: 6,
              map: 'https://srmcgann.github.io/Coordinates/resources/nebugrid_po2.jpg'
            }
            await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
              shapes.push(geometry)
              await shader.ConnectGeometry(geometry)
            })
          }
          if(1) for(var m=2; m--;) {
            var geoOptions = {
              shapeType: 'sprite',
              name: 'sprite',
              x: tx*4,
              y: ty*4 + 10,
              z: .5*(m?1:-1),
              size: 2.5,
              map: `https://srmcgann.github.io/Coordinates/resources/stars/star${(i/2|0)+m%2?3:8}.png`
            }
            await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
              shapes.push(geometry)
              await nullShader.ConnectGeometry(geometry)
            })
          }
        }
      })
        
      var floor = (X, Z) => {
        var ret = 0
        var d = Math.hypot(X, Z)
        var p = Math.atan2(X, Z)
        //ret = Math.min(5, Math.max(-5, (C(X / 40 + renderer.t*2) * C(Z/40)) * C(p+d/40-renderer.t*10) * 30)) - 10
        ret = Math.min(5, (C(X / 40 + renderer.t*2) * C(Z/40)) * C(p+d/20-renderer.t*10) * 30) - 10
        return ret
      }
      
      window.Draw = () => {
        if(1)shaders.map(shader => {
          shader.datasets.map(dataset=>{
            if(typeof dataset?.optionalUniforms != 'undefined'){
              dataset.optionalUniforms.filter((oU, idx) => {
                if(oU.name == 'phong') {
                  dataset.optionalUniforms[idx].theta = renderer.yaw + Math.PI + .3
                }
              })
            }
          })
        })

        renderer.z = Math.min(100, Math.max(32, (.3-C(renderer.t/4))*250))
        renderer.yaw += .005
        renderer.pitch = Math.min(1, Math.max(.05, (.2+C(renderer.t/1.5))*3))
        shapes.forEach((shape, idx) => {
          switch(shape.name){
            case 'background': case 'sprite':
            break
            case 'light':
              X = shape.x
              Z = shape.z
              p = Math.atan2(X,Z) - .05
              var d = Math.hypot(X,Z)
              shape.x = S(p) * d
              shape.z = C(p) * d
            break
            case 'floor':
              var v = shape.vertices
              var normals = []
              var facet = []
              for(var i = 0; i<v.length; i+=3){
                X = v[i+0]
                Y = v[i+1]
                Z = v[i+2]
                
                Y = floor(X, Z)
                
                v[i+0] = X
                v[i+1] = Y
                v[i+2] = Z
                facet = [...facet, [X, Y, Z]]
                if(i%9 == 6){
                  var n = Coordinates.Normal(facet)
                  normals = [...normals, n, n, n]
                  facet = []
                }
              }
              // average normal vecs
              var avN = new Float32Array()
              for(var i=0; i< v.length; i+=3){
                var nx1 = v[i+0]
                var ny1 = v[i+1]
                var nz1 = v[i+2]
                var nidx1 = i/3|0
                var nx2 = normals[nidx1][3] - normals[nidx1][0]
                var ny2 = normals[nidx1][4] - normals[nidx1][1]
                var nz2 = normals[nidx1][5] - normals[nidx1][2]
                var ct = 0
                a = [0,0,0]
                floorNormalAssocs[nidx1].map(idx =>{
                  var nidx = idx / 3 | 0
                  a[0] += normals[nidx][3] - normals[nidx][0]
                  a[1] += normals[nidx][4] - normals[nidx][1]
                  a[2] += normals[nidx][5] - normals[nidx][2]
                  ct ++
                })
                a[0] /= ct
                a[1] /= ct
                a[2] /= ct
                avN = [...avN, ...a]
                shape.normals[i*2+0] = nx1
                shape.normals[i*2+1] = ny1
                shape.normals[i*2+2] = nz1
                shape.normals[i*2+3] = nx1 + a[0]
                shape.normals[i*2+4] = ny1 + a[1]
                shape.normals[i*2+5] = nz1 + a[2]
              }
              var n = shape.normalVecs
              for(var i = 0; i<n.length; i++) n[i] = avN[i]
              //shape.yaw += .0025
            break
            default:
              //shape.color = Coordinates.HexFromHSV(idx*60+Coordinates.t*50,1,1),
              //shape.roll += .02
              //shape.yaw += .01
              //shape.pitch += .005
            break
          }
          renderer.Draw(shape)
        })
      }
    </script>
  </body>
</html>


<!--
  TO DO
  
  * re make OBJLoader method, to spec

  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       ✔  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom / glow shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->