<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">

      import * as Coordinates from
      "./coordinates.js"

      // instantiate a canvas. this is also our 'camera'
      var renderer = await Coordinates.Renderer({ambientLight:.8})
      
      // back the camera away from the center (move it toward the viewer)
      renderer.z = 10
      renderer.ambientLight = 1
      
      // tell the API where to find our animation function
      Coordinates.AnimationLoop(renderer, 'Draw')

      var vidSrc = 'https://srmcgann.github.io/skyboxes5/videos/cylindricalTurtles.mp4'

      // invoke a shader - phong in this case for a pseudo-lighting effect
      var shaderOptions = [
        { uniform: { type: 'phong', value: .85 } },
        { uniform: { type: 'reflection', value: .5, map: vidSrc, enabled: true } },
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)

      
      shaderOptions = [
        { uniform: { type: 'phong', value: 1 } },
        { uniform: { type: 'reflection', value: .5, map: vidSrc, enabled: false } },
      ]
      var backgroundShader = await Coordinates.BasicShader(renderer, shaderOptions)

      var C = Math.cos
      var S = Math.sin
      var Rn = Math.random
      
      var shapes = []

      var geoOptions = {
        shapeType: 'cube', subs: 1,
        size: 1500,
        name: 'background',
        //equirectangular: true,
        //scaleX: 1.777777778,
        //muted: false,
        sphereize: 1,
        equirectangular: true,
        averageNormals: true,
        z: 0,
        pitch: 0,
        playbackSpeed: 1,
        map: vidSrc,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await backgroundShader.ConnectGeometry(geometry)
      })  
      
      var sp = 40
      var cl = 3
      var rw = 1
      var br = 3
      for(var m = cl*rw*br; m--; ){
        var geoOptions = {
          shapeType: 'custom shape',
          url: 'https://srmcgann.github.io/Coordinates/custom shapes/ladybug.json',
          size: 1.5,
          //subs: 2,
          
          //averageNormals: true,
          //sphereize: 1,
          //color: 0xff0000,
          //objY: 10,
          equirectangular: true,
          //showNormals: true,
          //flipNormals: true,
          x: ((m%cl)-cl/2+.5) * sp,
          y: (((m/cl|0)%rw)-rw/2+.5) * sp - 0,
          z: ((m/cl/rw|0)-br/2+.5) * sp,
          map: 'https://srmcgann.github.io/Coordinates/custom%20shapes/LADYBUG.jpg',
          //exportShape: true
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
          shapes.push(geometry)
          await shader.ConnectGeometry(geometry)
        })
      }
      
      window.Draw = () => {
      
        var t = renderer.t
        shader.datasets.map(data=>{
          if(data?.optionalUniforms != 'undefined'){
            if(data.optionalUniforms?.length) data.optionalUniforms.filter(q=>q.name == 'phong').map(n=>{
              n.theta -= .075
            })
          }
        })
        backgroundShader.datasets.map(data=>{
          if(data?.optionalUniforms != 'undefined'){
            if(data.optionalUniforms?.length) data.optionalUniforms.filter(q=>q.name == 'phong').map(n=>{
              n.theta -= .075
            })
          }
        })
      
        //renderer.Clear()
        renderer.z = Math.min(42, Math.max(10, (.3+C(t/6))*90))
        renderer.yaw += .005
        renderer.pitch = .25 + Math.cos(renderer.t/3) 
      
        shapes.forEach(async (shape, idx) => {
          switch(shape.name){
            case 'background': break
            default:
              shape.yaw   += S(t + idx)  * .005 - .01
              shape.pitch += C(idx*8 + t*2) * .03 - .02
              shape.roll += C(idx + t/2) * .02
            break
          }
          await renderer.Draw(shape)
        })
      }
    </script>

  </body>
</html>


<!--
  TO DO
  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       *  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->