<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">

      import * as Coordinates from
      "./coordinates.js"

      var renderer = await Coordinates.Renderer({ambientLight: -.2, fov: 1600})
      renderer.z = 20
      renderer.yaw = 0
      Coordinates.AnimationLoop(renderer, 'Draw')
      var shaderOptions = [
        { uniform: { type: 'phong', value: .5 } },
        { uniform: { type: 'reflection', value: .5,
          map:"https://srmcgann.github.io/skyboxes3/HDRI/alices.jpg"
          } }
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)
      
      var floorShader = await Coordinates.BasicShader(renderer,
          [
            { uniform: { type: 'phong', value: .1 }},
            { uniform: { type: 'reflection', value: 1, enabled: false,
          map:"https://srmcgann.github.io/skyboxes3/HDRI/alices.jpg"
            }},
          ] )
            
      var reflectionOnlyShader = await Coordinates.BasicShader(renderer,
          [
            { uniform: { type: 'reflection', value: .5, enabled: true,
          map:"https://srmcgann.github.io/skyboxes3/HDRI/alices.jpg"
            }},
          ] )
            
      var shapes = []
      
      var S = Math.sin
      var C = Math.cos
      var shapeType
      var x=0, y=0, z=0
      
      var geoOptions = {
        color: 0x888888,
        colorMix: .2,
        shapeType: 'dodecahedron',
        name: 'background',
        subs: 3,
        sphereize: 1,
        equirectangular: true,
        //averageNormals: true,
        //flipNormals: true,
        map: 'https://srmcgann.github.io/skyboxes3/HDRI/alices.jpg',
        showNormals: false,
        x,
        y,
        z,
        size: 5000,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        //await floorShader.ConnectGeometry(geometry)
      })
      
      var geoOptions = {
        color: 0xffffff,
        colorMix: .75,
        shapeType: 'rectangle',
        name: 'floor',
        subs: 4,
        sphereize: 0,
        //averageNormals: true,
        //map: 'https://i.imgur.com/cR8S2TC.mp4',
        showNormals: false,
        x,
        y: -50,
        z,
        size: 300,
        pitch: Math.PI/2,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await floorShader.ConnectGeometry(geometry)
      })
      

      for(var i = 0; i<3; i++){
        switch(i%1){
          case 0: shapeType = 'tetrahedron'; break
          case 1: shapeType = 'tetrahedron'; break
          case 2: shapeType = 'octahedron'; break
          case 3: shapeType = 'dodecahedron'; break
          case 4: shapeType = 'icosahedron'; break
        }
        x = S(p=Math.PI*2/3*i) * 68
        y = 0
        z = C(p) * 68
        var geoOptions = {
          //color: 0xffffff,
          //colorMix: 1.0,
          shapeType,
          subs: 3,
          sphereize: 8,
          averageNormals: true,
          x, y, z,
          size: 6,
          map: 'https://srmcgann.github.io/Coordinates/resources/nebugrid_po2.jpg'
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
          shapes.push(geometry)
          await shader.ConnectGeometry(geometry)
        })
      }

      var geoOptions = {
        shapeType: 'torus knot',
        name: 'centerpiece',
        //url: './custom shapes/ladybug.json',
        size: 4,
        color: 0x000000,
        colorMix: .5,
        x: 0,
        y: 0,
        z: 0,
        //subs: 2,
        //sphereize: -.5,
        //averageNormals: true,
        showNormals: false,
        flipNormals: false,
        equirectangular: true,
        map: 'https://srmcgann.github.io/Coordinates/custom shapes/LADYBUG.jpg'
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await reflectionOnlyShader.ConnectGeometry(geometry)
      })
      
      var sd = 3
      var ls = 120
      var p, x, y, z
      for(var i=0; i<sd; i++){
        x = S(p=Math.PI*2/sd*i) * ls
        y = 0
        z = C(p) * ls
        var geoOptions = {
          color: Coordinates.HSVToHex(360/sd*i,1,1),
          shapeType: 'point light',
          x,
          y: 10,
          z,
          size: 36,
          pointLightShowSource: true
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => { shapes.push(geometry) })
      }
      
      var geoOptions = {
        color: 0xffbb88,
        //colorMix: 1.0,
        name: 'star',
        shapeType: 'point light',
        subs: 0,
        //sphereize: 8,
        //averageNormals: true,
        x:0,
        y:0,
        z:0,
        size: 16,
        map: 'https://srmcgann.github.io/Coordinates/resources/stars/star1.png'
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        //await shader.ConnectGeometry(geometry)
      })
      

      window.Draw = () => {
        renderer.z = Math.min(200, Math.max(20, (.3+C(renderer.t/8))*1E3))
        renderer.pitch = Math.min(1, Math.max(0, (.3+C(renderer.t/2)) * 1.5))
        renderer.yaw +=  .005
        var ct = 0, X, Y, Z, d
        shapes.forEach((shape, idx) => {
          switch(shape.shapeType){
            case 'point light':
              if(shape.name == 'star') break
              ct++
              shape.color = Coordinates.HSVToHex(360/sd*ct+renderer.t*20,1,1)
              X = shape.x
              Y = shape.y
              Z = shape.z
              var p = Math.atan2(X, Z) + S(renderer.t/4)* .05
              var d = Math.hypot(X, Z)
              shape.x = S(p) * d
              shape.y = C(renderer.t*4) * 32
              shape.z = C(p) * d
            break
          }
          
          switch(shape.name){
            case 'star':
              var mag = (1 + C(renderer.t*32) / 9) * shape.size * 1
              d = 0
              for(var i = 0; i<shape.vertices.length; i+=3){
                d += Math.hypot(shape.vertices[i+0],
                                shape.vertices[i+1],
                                shape.vertices[i+2])
              }
              d /= shape.vertices.length/3
              for(var i = 0; i<shape.vertices.length; i+=3){
                X = shape.vertices[i+0] / d
                Y = shape.vertices[i+1] / d
                Z = shape.vertices[i+2] / d
                shape.vertices[i+0] =  X * mag
                shape.vertices[i+1] =  Y * mag
                shape.vertices[i+2] =  Z * mag
              }
            break
            case 'background': case 'floor':
            break
            //case 'centerpiece':
            //  shape.yaw   += .02
            //break
            default:
              shape.yaw   += S(idx + renderer.t) * .01
              shape.roll   += C(idx + renderer.t) * .02
              shape.pitch += .005
            break
          }
          renderer.Draw(shape)
        })
      }
    </script>

  </body>
</html>


<!--
  TO DO
  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       *  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->