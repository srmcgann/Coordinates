<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">
    
      import * as Coordinates from
      "./coordinates.js"
    
      // instantiate a canvas, 'renderer'. this is also our 'camera'
      var rendererOptions = {
        ambientLight: .5,
        fov: 1500
      }
      var renderer = await Coordinates.Renderer(rendererOptions)
      
      // back the camera away from the center (move it toward the viewer)
      renderer.z = 10
      
      // tell the API where to find our animation function
      Coordinates.AnimationLoop(renderer, 'Draw')

      // invoke a shader - phong in this case for a pseudo-lighting effect
      var shaderOptions = [
        { uniform: {
          type: 'phong',
          value: 0
        } }
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)


      // create a scene (it's async, so we can 'await' each call, but that is optional)
      
      var P = []
      var iPv = .001
      var iPfreq = 60
      var Rn = Math.random
      var S = Math.sin
      var C = Math.cos
      var p, d, q
      var spawnP = async (x, y, z) => {
        var vx = S(p=Rn()*Math.PI*2) * S(q=Rn()<.5?Math.PI/2*Rn()**.5:Math.PI-Math.PI/2*Rn()**.5) * iPv
        var vy = C(q) * iPv
        var vz = C(p) * S(q) * iPv
        var geoOptions = {
          shapeType: 'sprite',
          color: 0xffffff,
          size: 1,
          x, y, z,
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async shape => {
          P = [...P, { vx, vy, vz, shape, age: 1}]
        })  
      }
      
        
      
      
      window.Draw = async () => {
      
        var t = renderer.t
        if(!t){
          await spawnP(0,0,0)
          await spawnP(0,0,0)
          await spawnP(0,0,0)
          console.log(P)
        }        
        
        renderer.yaw += .01
        
        //if(!((t*60|0)%iPfreq)) await spawnP(0,0,0)
        
        //P = P.filter(v=>v.age>0)
        P.forEach(v => {
          /*v.age -= .001
          v.shape.x += v.vx
          v.shape.y += v.vy
          v.shape.z += v.vz
          for(var i=0; i<v.shape.vertices.length; i+= 3){
            var X = v.shape.vertices[0+i]
            var Y = v.shape.vertices[1+i]
            var Z = v.shape.vertices[2+i]
            //d = Math.hypot(X,Y,Z)
            //X /= d
            //Y /= d
            //Z /= d
            //X *= v.age
            //Y *= v.age
            //Z *= v.age
            v.shape.vertices[0+i] = X
            v.shape.vertices[1+i] = Y
            v.shape.vertices[2+i] = Z
          }*/
          renderer.Draw(v.shape)
        })
      }
      
    </script>
  </body>
</html>


<!--
  TO DO
  
  * re make OBJLoader method, to spec

  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       ✔  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom / glow shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->