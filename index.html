<!--
  TO DO
  
  ✔ add renderer object
  ✔ add camera object
  
  * subdivision
    └> * add optional LOD param for all basic geometry
       * decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders
    └> ✔ move shaders into Coordinates module
       *  move camera into vertex shader
       *  create pseudo-phong shader
       *  integrate optional effect shaders

  * add shapes (in addtion to Cube)

  * functions / methods
    └> * begin separating module functions as optional includes
       * migrate functions to coordinates.js module
       * integrate obj loader

  * geometry
    └> * generalize geometry function
       * return "raw" geometry with inbuilt shapes, for 2d context

       
-->

<!DOCTYPE html>
<html>
  <head>
    <style>
      body, html{
        background: #000;
        margin: 0;
        min-height: 100vh;
        color: #fff;
        font-family: monospace;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <div id="output"></div>
    <script type="module">
    
      import * as Coordinates from "./coordinates.js"

      var renderer, geometry, shader
    
      renderer = Coordinates.Renderer(1920, 1080)
      
      renderer.z   = 20
      
      Coordinates.AnimationLoop(renderer, 'Draw')
      //geometry = Coordinates.LoadGeometry(renderer, 'obj', 10, 3, 0, true, true,
      //                                    'https://srmcgann.github.io/objs/axe.obj')
      geometry = Coordinates.LoadGeometry(renderer, 'cube', 10, 3, 0, true, true)
      //geometry = Coordinates.LoadGeometry(renderer, 'dodecahedron', 24, 0, 1, true, true)
      shader = Coordinates.BasicShader(renderer)
      
      shader.ConnectGeometry(geometry)
      
      
      var t = 0
      var S = Math.sin, C = Math.cos
      
      window.Draw = () => {

        var X, Y, Z, e
        
        if(1) for(let i = 0; i<geometry.vertices.length; i+=3){
          X = geometry.vertices[i+0]
          Y = geometry.vertices[i+1]
          Z = geometry.vertices[i+2]

          e = Coordinates.R(X,Y,Z, {x:0, y:0, z:0,
                                    roll:  0,
                                    pitch: -.002,
                                    yaw:   .001}, false)
          geometry.vertices[i+0] = e[0]
          geometry.vertices[i+1] = e[1]
          geometry.vertices[i+2] = e[2]
        }
        
        if(1) for(let i = 0; i<geometry.normals.length; i+=3){
          X = geometry.normals[i+0]
          Y = geometry.normals[i+1]
          Z = geometry.normals[i+2]
          e = Coordinates.R(X,Y,Z, {x:0, y:0, z:0,
                                    roll:  0,
                                    pitch: -.002,
                                    yaw:   .001}, false)
          geometry.normals[i+0] = e[0]
          geometry.normals[i+1] = e[1]
          geometry.normals[i+2] = e[2]
        }

        
        renderer.Clear()
        
        //renderer.z = Math.min(20, Math.max(0, (.3 + C(t/4))*50))

        renderer.Draw(geometry, shader)

        /*
        
        renderer.Clear()

        renderer.x     = 0
        renderer.y     = 0
        renderer.z     = 16
        renderer.roll  = 0
        renderer.pitch = -t/2
        renderer.yaw   = t

        cube.map(v=>{
          renderer.ctx.beginPath()
          v.map(q=>{
            X = q[0]
            Y = q[1]
            Z = q[2]
            var e = Coordinates.R(X,Y,Z, renderer, true)
            X = e[0]
            Y = e[1]
            Z = e[2]
            if(Z>0) renderer.ctx.lineTo(...Coordinates.Q(X, Y, Z, c))
          })
          renderer.ctx.lineWidth = 50/Z
          renderer.ctx.strokeStyle = `#f004`
          renderer.ctx.fillStyle = `#f001`
          renderer.ctx.stroke()
          renderer.ctx.strokeStyle = `#f008`
          renderer.ctx.lineWidth /= 4
          renderer.ctx.stroke()
          renderer.ctx.fill()
        })
        */
        t += 1/60
      }
      
    </script>
  </body>
</html>