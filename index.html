<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">
    
      import * as Coordinates from "./coordinates.js"
    
      var renderer = await Coordinates.Renderer({fov:1e3, ambientLight: 0})
      
      renderer.z = 1500
      var S = Math.sin
      var C = Math.cos
      
      Coordinates.AnimationLoop(renderer, 'Draw')

      var shaderOptions = [ { uniform: { type: 'phong', value: 2 } } ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)

      console.log(shader)

      var shaderOptions = [ { uniform: { type: 'phong', value: 0 } } ]
      var skyboxShader = await Coordinates.BasicShader(renderer, shaderOptions)


      var shapes = []
      var geoOptions

      geoOptions = {
        shapeType: 'icosahedron',
        name: 'background',
        averageNormals: true,
        subs: 1,
        colorMix: 0,
        sphereize: 1,
        size: 1e4,
        map: 'https://srmcgann.github.io/Coordinates/resources/stars_po2.jpg'
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await skyboxShader.ConnectGeometry(geometry)
      })  
      
      var sizes = [
        500,    // mercury
        40,    // venus
        50,    // earf
        30,    // mars
        90,    // saturn
        120,   // jupiter
        100,   // uranus
        90,    // neptune
        90,    // pluto
      ]

      for(var i =0; i<9; i++){
        geoOptions = {
          shapeType: 'icosahedron',
          subs: 1,
          name: 'planet',
          planetID: i,
          size: sizes[i],
          x: 0,
          y: 0,
          z: (300*(i + 2))**1.2,
          averageNormals: true,
          sphereize: 1,
          color: Coordinates.HexFromHSV(360/9*i, 1, 1),
          colorMix: .5,
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
          shapes.push(geometry)
          await shader.ConnectGeometry(geometry)
        })
      }
            
      var p, d, x, y, z
      var cl = 1
      var rw = 1
      var br = 1
      var sp = 1e3
      Array(cl*rw*br).fill().map(async (v, i) => {
        x = ((i%cl)-cl/2 + .5) * sp
        y = (((i/cl|0)%rw)-rw/2 + .5) * sp
        z = ((i/cl/rw|0)-br/2 + .5) * sp
        if(Math.hypot(x,y,z) < 11000){
          for(var m = 1; m--;){
            geoOptions = {
              shapeType: m<2 ? 'point light' : 'point light',
              name: 'star',
              color: 0xffffff,
              pointLightShowSource: true,
              size: 1e3,
              lum: 1e4,
              subs: -1,
              disableDepthTest: false,
              x, y, z,
              map: 'https://srmcgann.github.io/Coordinates/resources/stars/star1.png',
            }
            await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
              shapes.push(geometry)
              //await shader.ConnectGeometry(geometry)
            })
          }
        }
      })

      window.Draw = () => {
      
        //renderer.Clear()
        renderer.z = Math.min(5000, Math.max(1e3, (.3-C(renderer.t/8))*1e4))
        renderer.yaw += .002
        renderer.pitch = Math.min(.75, Math.max(.1, (.3+C(renderer.t/4))*1.2))
        shapes.forEach(shape => {
          switch(shape.name){
            case 'star':
            break
            case 'background':
            break
            case 'planet':
              shader.datasets.map(v=>{
                if(typeof v?.optionalUniforms != 'undefined'){
                  let phongShader = v.optionalUniforms.filter(v=>v.name=='phong')
                  if(phongShader.length) phongShader[0].theta = -Math.atan2(shape.x, shape.z) + Math.PI
                }
              })
              var X = shape.x
              var Y = shape.y
              var Z = shape.z
              var p = Math.atan2(X, Z) + .2 * (1/(3 + shape.planetID)**2)
              var d = Math.hypot(X, Z)
              shape.x = S(p) * d
              shape.z = C(p) * d
            break
            default:
            
            break
          }
          //shape.yaw   += .01
          //shape.pitch += .005
          renderer.Draw(shape)
        })
      }
      
    </script>
  </body>
</html>

<!--
  TO DO
  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       *  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->