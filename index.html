<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #333;
        margin: 0;
        min-height: 100vh;
      }
    </style>
  </head>
  <body>
    <script type="module">
    
      import * as Coordinates from
      "./coordinates.js"

      var rendererOptions = {
        ambientLight: .2,
        fov: 1400, 
        cameraMode: 'fps'
      }
      var renderer = await Coordinates.Renderer(rendererOptions)
      
      var S = Math.sin
      var C = Math.cos
      var Rn = Math.random
      
      renderer.z = 0
      
      var refTexture = 'https://srmcgann.github.io/Coordinates/resources/spacemaze_po2.jpg'
      
      Coordinates.AnimationLoop(renderer, 'Draw')

      var shaderOptions = [
        { lighting: {
          type: 'ambientLight', value: .1,
        }
        },
        { uniform: {
          type: 'phong',
          value: .4
        } },
        { uniform: {
          type: 'reflection', value: .5, map: refTexture,
        }}
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shaderOptions = [
        { lighting: {
          type: 'ambientLight', value: .1,
        }},
        { uniform: {
          type: 'phong',
          value: 0
        } },
      ]
      var backgroundShader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shapes = []
      
      var geoOptions = {
        shapeType: 'dodecahedron',
        name: 'background',
        subs: 2,
        map: refTexture,
        size: 1e3,
        color: 0xffffff,
        colorMix: 0,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await backgroundShader.ConnectGeometry(geometry)
      })  
      
      var geoOptions = {
        shapeType: 'cube',
        subs: 2,
        sphereize: .5,
        equirectangular: true,
        averageNormals: true,
        map: 'https://srmcgann.github.io/Coordinates/resources/nebugrid_po2.jpg',
        size: 5,
        color: 0xffffff,
        colorMix: 0,
      }
      if(0) await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await shader.ConnectGeometry(geometry)
      })  
      
      var cl = 100
      var rw = 1
      var br = 100
      var sp = 2
      var ox = 0
      var oy = -10
      var oz = 0
      
      var floor = (X, Z) => {
        var d = Math.hypot(X, Z)
        return oy//S(d/10 - renderer.t*2) * 6 + oy
      }
      
      var geometryData = []
      var iPc = Array(cl*br*rw).fill().map((v, i) => {
        var X = ((i%cl)-cl/2 + .5) * sp
        var Z = ((i/cl/rw|0)-br/2 + .5) * sp
        var Y = floor(X, Z) //(((i/cl|0)%rw)-rw/2 + .5) * sp
        geometryData = [...geometryData, [X,Y,Z]]
      })
      
      var geoOptions = {
        shapeType: 'particles',
        size: 1,
        name: 'particles',
        penumbra: .5,
        alpha: 1,
        geometryData,
        color: 0xffffff,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        //await shader.ConnectGeometry(geometry)
      })  
      
      
      const loadFPSControls = async (renderer, options) => {

        var mspeed = 1
        var rspeed = 1
        var grav   = .01
        var crosshairSel = 0
        var crosshairMap = ''
        var crosshairShape
        renderer.showCrosshair = true
        var crosshairs = Array(3).fill().map((v, i) => `${Coordinates.ModuleBase}/resources/crosshairs/crosshair${i+1}.png`)
        if(typeof options != 'undefined'){
          Object.keys(options).forEach((key, idx) =>{
            switch(key.toLowerCase()){
              case 'mspeed': mspeed = options[key]; break
              case 'rspeed': rspeed = options[key]; break
              case 'grav': grav = options[key]; break
              case 'crosshairsel': crosshairSel = options[key]; break
              case 'crosshairmap': crosshairMap = options[key]; break
              case 'showcrosshair': showCrosshair = !!options[key]; break
            }
          })
        }

        if(renderer.showCrosshair){
          var geoOptions = {
            shapeType: 'sprite',
            name: 'FPS crosshair',
            map: crosshairMap ? crosshairMap : crosshairs[crosshairSel],
            size: 1,
            color: 0xffffff,
            colorMix: 0,
            z: -5,
          }
          await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
            crosshairShape = geometry
          })
        }
        


        var mx, my
        var mv = .2 * mspeed
        var rv = .006 * rspeed
        var rvx = 0
        var rvy = 0
        var px  = 0
        var py  = 0
        var pz  = 0
        var pvx = 0
        var pvy = 0
        var pvz = 0
        var accel = 1
        var rdrag = 2
        var pdrag = 2
        var mbutton = false
        renderer.keys = Array(256).fill().map((v, i) => false)
        renderer.keyTimers = Array(256).fill(0)
        renderer.keyTimerInterval = .2
        window.addEventListener('keydown', e => {
          console.log(e.keyCode)
          renderer.keys[e.keyCode] = true
        })
        window.addEventListener('keyup', e => {
          renderer.keys[e.keyCode] = false
        })
        window.addEventListener('mousedown', e => {
          if(e.button === 0) {
            mbutton = true
            //jump()
            //renderer.c.requestFullscreen()
            renderer.c.requestPointerLock()
          }
        })
        window.addEventListener('mouseup', e => {
          if(e.button === 0) mbutton = false
        })
        window.addEventListener('mousemove', e => {
          var rect = renderer.c.getBoundingClientRect()
          mx = (e.pageX - rect.left) / renderer.c.clientWidth * renderer.c.width
          my = (e.pageY - rect.top) / renderer.c.clientHeight* renderer.c.height
          rvx -= e.movementX * rv * accel
          rvy += e.movementY * rv * accel
        })
        
        renderer.doKeys = async () => {
        
          if(renderer.showCrosshair) renderer.Draw(crosshairShape)
        
          renderer.yaw += rvx
          renderer.pitch += rvy
          renderer.pitch = Math.min(Math.PI/2, Math.max(-Math.PI/2, renderer.pitch))
          rvx /= rdrag
          rvy /= rdrag
          
          renderer.x += pvx
          renderer.y += pvy
          renderer.z += pvz
          pvx /= pdrag
          pvy /= pdrag
          pvz /= pdrag
          
          accel = 1
          renderer.keys.map((v, i) => {
            if(renderer.keys[i]){
              switch(i){
                case 16:  // shift
                  accel = 3
                break
                case 37:  // left arrow
                break
                case 38:  // up arrow
                break
                case 39:  // right arrow
                break
                case 40:  // down arrow
                break
                case 87:  //w
                  var p1 = -renderer.yaw + Math.PI
                  var p2 = renderer.pitch
                  pvx += S(p1) * mv * accel
                  pvz += C(p1) * mv * accel
                break
                case 65:  //a
                  var p1 = -renderer.yaw + Math.PI / 2
                  var p2 = renderer.pitch
                  pvx += S(p1) * mv * accel
                  pvz += C(p1) * mv * accel
                break
                case 83:  //s
                  var p1 = -renderer.yaw + Math.PI
                  var p2 = renderer.pitch
                  pvx -= S(p1) * mv * accel
                  pvz -= C(p1) * mv * accel
                break
                case 68:  //d
                  var p1 = -renderer.yaw + Math.PI / 2
                  var p2 = renderer.pitch
                  pvx += -S(p1) * mv * accel
                  pvz += -C(p1) * mv * accel
                break
                case 32:  //space
                break
              }
            }
          })
        }
        
        setInterval( await renderer.doKeys, 1000/60)
      }
      
      await loadFPSControls(renderer, .7)
      
      
      window.Draw = () => {
        var t = renderer .t
        //renderer.z = Math.min(100, Math.max(16, (.3 + C(t/3))*150))
        //renderer.yaw += .001
        shapes.forEach(shape => {
          switch(shape.name){
            case 'background':
            break
            case 'particles':
              for(var i = 0; i<shape.vertices.length; i+=3){
                var X = shape.vertices[i+0]
                var Y = shape.vertices[i+1]
                var Z = shape.vertices[i+2]
                
                Y = floor(X,Z)
                
                shape.vertices[i+0] = X
                shape.vertices[i+1] = Y
                shape.vertices[i+2] = Z
              }
            break
            
            default:
              shape.yaw += .01
              shape.pitch += .005
            break
          }
          renderer.Draw(shape)
        })
      }
      
    </script>
  </body>
</html>


<!--
  TO DO
  
  * re make OBJLoader method, to spec

  
  ✔ re: 'sphereize', the problem exists of needing to average
         normals AFTER the shape is sphereized, as the degree is
         not known prior. Normal averaging is computationally
         expensive, so a solution, in the context of pre-built shapes,
         is to provide an optional function "AverageNormals", and
         instruct users that sphereized shapes may use it, for
         reflections etc.
  
  ✔ re-export 'new shapes' with unit size
  ✔ fix color mix
  ✔ come up with solution for averaging normals (for phong etc), with prebuilt shapes
  
  * 'grouping' / 'ungrouping' option
        for geometry, which makes drawing buffers contiguous
  
  ✔ sprites [transparent rectangle?]
  
  ✔ make uniforms: position, normal etc vec3, vs separate floats
  
  * lights
    └> ✔ ambient
       ✔  point
       *  directional
  
  * geometry
    └> ✔ generalize geometry function
       ✔ add shapeTypes: torus, cylinder
       *  add method / shapeType for points/particles, lines
       *  noise functions / deformation methods
       ✔ return "raw" geometry with inbuilt shapes, for 2d context
       ✔ add 3-axis 'scale' function 
       
  ✔ README.md
    └> ✔  add remaining exposed methods (e.g. color conversions, spatial)
          as "supplemental"
  
  ✔ add renderer object
  ✔ add camera object
  ✔ fix FOV
  ✔ README.md / documentation
  
  * sprite sheet system / import basic+custom slicing
  ✔ add video texture capabilities
  * cache for API, to include all network-callable items
  
  * shapes
    └> ✔ add shapes (in addtion to Cube)
       ✔ make non-cube UVs equirectangular
       ✔ keep shape generation functions, but add 'precompiled' versions for ordinary calls
       ✔ move rotation function into shader
       * loading -> compression, direct output of
                    usable format (no further processing needed)

  * subdivision
    └> ✔  add optional LOD param for all basic geometry
       ✔ decouple polygons from UV subdivision (interpolate UVs @ sub)
       
  * shaders / textures
    └> ✔ move shaders into Coordinates module
       *  bloom / glow shader
       *  add '# tiling (x/y)' option
       ✔  phong -> play nice with rectangle
       ✔  move camera into vertex shader
       ✔  create pseudo-phong shader
       ✔  add 'reflectivity' & texture input for it
       ✔  flat/smooth shading
       ✔  integrate optional effect shaders

  * functions / methods
    └> ✔ begin separating module functions as optional includes
       ✔ migrate functions to coordinates.js module
       ✔ integrate obj loader

-->